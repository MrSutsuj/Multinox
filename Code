#include "U8glib.h"                               //Einbindung der Bibliothek "U8glib" zur Beschriftung des Displays
#include <Artnet.h>                               //Einbindung der Bibliothek "Artnet", ohne Versatz zum Array
#include <Ethernet.h>                             //Einbindung der Bibliothek "Ethernet" zur Verwendung der Ethernet-Schnittstelle
#include <DMXSerial.h>                            //DMX-Input-Bibliothek, Versatz um +1 zum Array, da Kanäle 1-512
#include <DmxSimple.h>                            //DMX-Output-Bibliothek, Versatz um +1 zum Array, da Kanäle 1-512
#define BTSerial Serial2                          //Definition der zweiten seriellen Ports für das Bluetooth-Modul
Artnet artnet;                                    //Zuweisung der Variablen artnet

U8GLIB_SH1106_128X64 u8g(U8G_I2C_OPT_NONE);       //Definition der Displaygröße

byte ip[] = {10, 0, 0, 41};                           //IP Adresse des Artnet-Ports festlegen
byte mac[] = {0x04, 0xE9, 0xE5, 0x00, 0x69, 0xEC};    //MAC Adresse des Arduinos festlegen

String modelabel = "DMX";                         //angezeigter Modus auf dem Display

int channel = 1;                                  //Channel-Cursor, um +1 Versatz da in DMX-Zählweise, nicht in Array-Zählweise
int mode = 1;                                     //Indikator des Modus
int ergebnis = 2;                                 //Ergebnis des Kabeltests (0=nicht bestanden; 1=bestanden; 2= Standby)
int count1 = 0;                                   //Zähler für Test-Sequenz
int displ = 1;                                    //Switch zur Ausgabe der Informationen über das Display (1=an, 0=aus)
int teststart = 0;                                //Start des Kabeltests, aktuell ohne Funktion
int btinit = 0;                                   //Bluetooth-Initialisierungs-Paket wird bei 1 gesendet

int channelold = 0;                               //bisheriger Kanal (dient nur zur Display-Aktualisierung, unabhängig vom Speicher)
int valueold = 0;                                 //bisheriger Wert (dient nur zur Display-Aktualisierung, unabhängig vom Speicher)
int statusold = 0;                                //bisheriger Status (dient nur zur Display-Aktualisierung, unabhängig vom Speicher)

int btdelay2 = 30;                                //Sende-Delay zur einwandfreien Übertragung
int btdelay3 = 5;                                 //Sende-Delay zur einwandfreien Übertragung

int dmxvalues[512];                               //Ausgangs-Speicher
int dmxvaluesin[512];                             //Eingangs-Speicher
int dmxbtstatus[512];                             //Status-Speicher (0=Werte werden durchgereicht, 1=Werte werden überschrieben)
int dmxbt[512];                                   //Überschreiben-Werte-Speicher

unsigned long presslength;                        //Zeitvariablen für langes Drücken und Lösen
unsigned long presslengthold;                     //Zeitvariablen für langes Drücken und Lösen
unsigned long presslengthnew;                     //Zeitvariablen für langes Drücken und Lösen


void setup() {

  artnet.begin(mac, ip);                          //Start des Artnet-Empfangs
  BTSerial.begin(115200);                         //Start der Bluetooth-Verbidung mit 115200 Baut
  Serial.begin(115200);                           //Starten des Serial-Monitors mit 115200 Baut


  for (int i = 0; i <= 511; i++) {                //Initialisierung der Werte-Speicher auf 0
    dmxvalues[i] = 0;                             //Ausgangs-Speicher
    dmxvaluesin[i] = 0;                           //Eingangs-Speicher
    dmxbtstatus[i] = 0;                           //Status-Speicher
    dmxbt[i] = 0;                                 //Überschreiben-Werte-Speicher
  }

  pinMode(10, OUTPUT);                            //LED grün
  pinMode(11, OUTPUT);                            //LED rot
  pinMode(30, INPUT_PULLUP);                      //oben
  pinMode(32, INPUT_PULLUP);                      //unten
  pinMode(34, INPUT_PULLUP);                      //links
  pinMode(36, INPUT_PULLUP);                      //rechts
  DMXSerial.init(DMXReceiver);                    //Einstellen der Serial-Bibliothek als DMX-Input
  DmxSimple.usePin(45);                           //Einstellen des Ausgangs für den DMX-Output

  delay(100);                                     //Setup-Delay

  digitalWrite(10, HIGH);                         //LED grün an
  digitalWrite(11, LOW);                          //LED rot aus
  delay(100);                                     //Setup-Delay
  digitalWrite(10, LOW);                          //LED grün aus
  digitalWrite(11, HIGH);                         //LED rot an 
  delay(100);                                     //Setup-Delay
  digitalWrite(10, HIGH);                         //LED grün an
  digitalWrite(11, LOW);                          //LED rot aus
  delay(100);                                     //Setup-Delay
  digitalWrite(10, LOW);                          //LED aus
  digitalWrite(11, LOW);                          //LED aus
  delay(100);

}


void dmxbtsend () {                               //DMX-Paket senden
  BTSerial.print("C");                            //Sende Paket-Indikator C
  BTSerial.print(channel);                        //Sende Channel
  BTSerial.print("/");                            //Sende Paket-Trenner
  BTSerial.print((dmxvalues[(channel - 1)]));     //Sende DMX-Ausgangswert für Channel
  BTSerial.print("X");                            //Sende Paket-Abschluss
}

void dmxlocksend () {                             //Status-Lock-Paket senden
  BTSerial.print("L");                            //Sende Paket-Indikator L
  BTSerial.print(channel);                        //Sende Channel
  BTSerial.print("/");                            //Sende Paket-Trenner
  BTSerial.print((dmxbtstatus[(channel - 1)]));   //Sende Status für Channel
  BTSerial.print("X");                            //Sende Paket-Abschluss
}


void sendandreset () {                      //DMX-Pakete senden und Zeiten-Reset
  dmxbtsend();                              //DMX-Paket senden
  dmxlocksend();                            //Status-Lock-Paket senden
  presslength = 0;                          //Zeit zurücksetzen
  presslengthnew = 0;                       //Zeit zurücksetzen
}

void draw() {                               //Display für DMX- und ArtNet-Modus
  u8g.setFont(u8g_font_profont12);          //Definition der Schriftart und -größe
  u8g.setPrintPos(0, 10);                   //Definition der Textposition
  u8g.print("Multinox");                    //Text-Ausgabe
  u8g.setPrintPos(0, 25);                   //Definition der Textposition
  u8g.print("Mode");                        //Text-Ausgabe
  u8g.setPrintPos(80, 25);                  //Definition der Textposition
  u8g.print(modelabel);                     //Modus-Ausgabe
  u8g.setPrintPos(0, 40);                   //Definition der Textposition
  u8g.print("Channel");                     //Text-Ausgabe
  u8g.setPrintPos(80, 40);                  //Definition der Textposition
  u8g.print(channel);                       //Wert-Ausgabe
  u8g.setPrintPos(0, 55);                   //Definition der Textposition
  u8g.print("DMX");                         //Text-Ausgabe
  u8g.setPrintPos(80, 55);                  //Definition der Textposition
  u8g.print(dmxvalues[(channel - 1)]);      //Wert-Ausgabe
  if (dmxbtstatus[(channel - 1)] == 1) {    //falls Status für Kanal gesetzt
    u8g.setPrintPos(100, 55);               //Definition der Textposition
    u8g.print("/o");                        //markiere Overwrite durch App oder Hardware
  }
}

void draw2() {                          //Display durch App ausgeschaltet
  u8g.setFont(u8g_font_profont12);      //Definition der Schriftart und -größe
  u8g.setPrintPos(0, 10);               //Definition der Textposition
  u8g.print("Multinox");                //Text-Ausgabe
  u8g.setPrintPos(0, 25);               //Definition der Textposition
  u8g.print("Display-Lock");            //Text-Ausgabe
}

void draw3() {                          //Display für Testmodus
  u8g.setFont(u8g_font_profont12);      //Definition der Schriftart und -größe
  u8g.setPrintPos(0, 10);               //Definition der Textposition
  u8g.print("Multinox");                //Text-Ausgabe
  u8g.setPrintPos(0, 25);               //Definition der Textposition
  u8g.print("Test Mode");               //Text-Ausgabe
  u8g.setPrintPos(0, 40);               //Definition der Textposition
  u8g.print("TESTING");                 //Text-Ausgabe
}

void loop() {                                         //Programm-Schleife

  if (BTSerial.available())                           //wenn Daten empfangen werden
  {
    String data = BTSerial.readStringUntil('X');      //schreibe Daten in String
    if (data.substring(0, 1) == "M") {                //wenn Paket-Indikator M (Modus-Pakete)
      if (data.substring(1, 2).toInt() == 0) {        //wenn der zu Integer gewandelte Wert an Stelle 1 gleich 0
        mode = 0;                                     //Setze mode 0
        channelold = 0;                               //reset channelold
      }
      if (data.substring(1, 2).toInt() == 1) {        //wenn der zu Integer gewandelte Wert an Stelle 1 gleich 1
        mode = 1;                                     //Setze mode 1
        channelold = 0;                               //reset channelold
      }
      if (data.substring(1, 2).toInt() == 2) {        //wenn der zu Integer gewandelte Wert an Stelle 1 gleich 2
        mode = 2;                                     //Setze mode 2
        channelold = 0;                               //reset channelold
      }
      BTSerial.print("M");                            //Sende Paket-Indikator M
      BTSerial.print(mode);                           //Sende Modus
      BTSerial.print("X");                            //Sende Paket-Abschluss
    }


    if (data.substring(0, 1) == "S") {                //wenn Paket-Indikator S(Initialisierungs-Anforderungs-Pakete)
      if (data.substring(1, 2).toInt() == 1) {        //eine 1 enthält
        btinit = 1;                                   //setze btinit auf 1
      }
      else {                                          //sonst
        btinit = 0;                                   //setze btinit auf 0
      }
    }

    if (data.substring(0, 1) == "I") {                        //wenn Paket-Indikator I (IP-Adressen-Pakete)
      ip[0] = data.substring(1, 4).toInt();                   //erster Array-Eintrag ist zu Integer gewandelter Wert an Stelle 1 bis 3
      ip[1] = data.substring(4, 7).toInt();                   //zweiter Array-Eintrag ist zu Integer gewandelter Wert an Stelle 4 bis 6
      ip[2] = data.substring(7, 10).toInt();                  //dritter Array-Eintrag ist zu Integer gewandelter Wert an Stelle 7 bis 9
      ip[3] = data.substring(10, 13).toInt();                 //vierter Array-Eintrag ist zu Integer gewandelter Wert an Stelle 10 bis 12    
      BTSerial.print("I");                                    //Sende Paket-Indikator I
      delay(btdelay2);                                        //Sende-Delay
      for (int i = 1; i <= 12; i++) {                         //for-Schleife mit 12 Schritten
        BTSerial.print(data.substring(i, (i + 1)).toInt());   //Sende die zu Integer gewandelten Werte vom Eingangsstring
        delay(btdelay2);                                      //Sende-Delay
      }
      BTSerial.print("X");                                    //Sende Paket-Abschluss
    }

    if (data.substring(0, 1) == "C") {                      //wenn Paket-Indikator C (DMX-Overwrite-Pakete)
      channel = data.substring(1, 4).toInt();               //Channel ist gleich dem zu Integer gewandelten Wert an Stelle 1 bis 3
      dmxbt[(channel - 1)] = data.substring(5, 8).toInt();  //Overwrite-Wert für Channel ist der zu Integer gewandelte Wert an Stelle 5 bis 7
      BTSerial.print("C");                                  //Sende Paket-Indikator C
      BTSerial.print(channel);                              //Sende Channel
      BTSerial.print("/");                                  //Sende Paket-Trenner
      BTSerial.print(dmxbt[(channel - 1)]);                 //Sende Overwrite-Wert für Channel
      BTSerial.print("X");                                  //Sende Paket-Abschluss
    }

    if (data.substring(0, 1) == "L") {                  //wenn Paket-Indikator L (Status-Lock-Pakete)
      channel = data.substring(1, 4).toInt();           //Channel ist gleich dem zu Integer gewandelten Wert an Stelle 1 bis 3
      if (data.substring(5, 6).toInt() == 0) {          //wenn der zu Integer gewandelte Wert an Stelle 5 gleich 0
        dmxbtstatus[(channel - 1)] = 0;                 //Setze dmxbtstatus für channel gleich 0
        dmxlocksend();                                  //Sende Status-Lock-Paket als Bestätigung
      }
      if (data.substring(5, 6).toInt() == 1) {          //wenn der zu Integer gewandelte Wert an Stelle 5 gleich 1
        dmxbtstatus[(channel - 1)] = 1;                 //Setze dmxbtstatus für channel gleich 1
        dmxlocksend();                                  //Sende Status-Lock-Paket als Bestätigung
      }
    }
    if (data.substring(0, 1) == "D") {                  //wenn Paket-Indikator D (Display-Pakete)
      if (data.substring(2, 3).toInt() == 0) {          //wenn Inhalt zu Integer gewandelt an Stelle 2 gleich 0
        displ = 0;                                      //schalte Display aus
      }
      else {                                            //sonst
        displ = 1;                                      //Schalte Display an
      }
    }
  }
  if (btinit == 1) {                                    //wenn Initialisierungs-Paket angefordert wird
    for (int i = 1; i <= 511; i++) {                    //for-Schleife zum Durchgehen aller Kanäle
      BTSerial.print("C");                              //Sende Paket-Indikator C
      BTSerial.print(i);                                //Sende Position der Schleife
      BTSerial.print("/");                              //Sende Paket-Trenner
      BTSerial.print(dmxvalues[(i - 1)]);               //Sende Wert
      BTSerial.print("X");                              //Sende Paket-Abschluss
      delay(btdelay3);                                  //Sende-Delay
      BTSerial.print("L");                              //Sende Paket-Indikator L
      BTSerial.print(i);                                //Sende Position der Schleife
      BTSerial.print("/");                              //Sende Paket-Trenner
      BTSerial.print(dmxbtstatus[(i - 1)]);             //Sende Status
      BTSerial.print("X");                              //Sende Paket-Abschluss
      delay(btdelay3);                                  //Sende-Delay
    }
    delay(100);                                         //Delay
    btinit = 0;                                         //resete Initialisierungs-Anforderung

    digitalWrite(10, HIGH);                             //LED grün an
    delay(100);                                         //Delay
    digitalWrite(10, LOW);                              //LED grün aus
    delay(100);                                         //Delay
    digitalWrite(10, HIGH);                             //LED grün an
    delay(100);                                         //Delay
    digitalWrite(10, LOW);                              //LED grün aus
    delay(100);                                         //Delay
    digitalWrite(10, HIGH);                             //LED grün an
    delay(100);                                         //Delay
    digitalWrite(10, LOW);                              //LED aus
    digitalWrite(11, LOW);                              //LED aus
    delay(300);                                         

  }

  if (mode == 0 && modelabel != "Test") {               //wenn Modus null und Label ungleich "Test" ist
    modelabel = "Test";                                 //Setze Label auf "Test"
    channelold = 0;                                     //resete channelold zur Aktualisierung des Displays (siehe unten)
  }
  if (mode == 1 && modelabel != "DMX") {                //wenn Modus null und Label ungleich "Test" ist
    modelabel = "DMX";                                  //Setze Label auf "DMX"
    channelold = 0;                                     //resete channelold zur Aktualisierung des Displays (siehe unten)
  }
  if (mode == 2 && modelabel != "ArtNet") {             //wenn Modus null und Label ungleich "Test" ist
    modelabel = "ArtNet";                               //Setze Label auf "ArtNet"
    channelold = 0;                                     //resete channelold zur Aktualisierung des Displays (siehe unten)
  }

  if (displ == 1) {                                     //wenn Display an ist
    if (mode == 0) {                                    //wenn Modus null ist
      u8g.firstPage();                                  //Schreibe erste Seite
      do {                                              //Führe aus
        draw3();                                        //Funktion Test-Modus
      } while (u8g.nextPage());                         //während Seite aktualisiert wird
    }
    if (mode == 1) {                                    //wenn Modus eins ist
      if (channelold != channel) {                      //wenn aktueller Channel ungleich altem Channel
        u8g.firstPage();                                //Schreibe erste Seite
        do {                                            //Führe aus
          draw();                                       //Funktion Kombimodus
        } while (u8g.nextPage());                       //während Seite aktualisiert wird
        channelold = channel;                           //Setze alten Channel gleich dem aktuellen Channel
      }
      if (valueold != dmxvalues[(channel - 1)]) {       //wenn aktueller Wert ungleich altem Wert
        u8g.firstPage();                                //Schreibe erste Seite
        do {                                            //Führe aus
          draw();                                       //Funktion Kombimodus
        } while (u8g.nextPage());                       //während Seite aktualisiert wird
        valueold = dmxvalues[(channel - 1)];            //Setze alten Wert gleich dem aktuellen Wert für Channel
      }
      if (statusold != dmxbtstatus[(channel - 1)]) {
        u8g.firstPage();                                //Schreibe erste Seite
        do {                                            //Führe aus
          draw();                                       //Funktion Kombimodus
        } while (u8g.nextPage());                       //während Seite aktualisiert wird
        statusold = dmxbtstatus[(channel - 1)];         //Setze alten Status gleich dem aktuellen Status für Channel
      }
    }
    if (mode == 2) {                                    //wenn Modus zwei ist
      if (channelold != channel) {                      //wenn aktueller Channel ungleich altem Channel
        u8g.firstPage();                                //Schreibe erste Seite
        do {                                            //Führe aus
          draw();                                       //Funktion Kombimodus
        } while (u8g.nextPage());                       //während Seite aktualisiert wird
        channelold = channel;                           //Setze alten Channel gleich dem aktuellen Channel
      }
      if (valueold != dmxvalues[(channel - 1)]) {       //wenn aktueller Wert ungleich altem Wert
        u8g.firstPage();                                //Schreibe erste Seite
        do {                                            //Führe aus
          draw();                                       //Funktion Kombimodus
        } while (u8g.nextPage());                       //während Seite aktualisiert wird
        valueold = dmxvalues[(channel - 1)];            //Setze alten Wert gleich dem aktuellen Wert für Channel
      }
      if (statusold != dmxbtstatus[(channel - 1)]) {
        u8g.firstPage();                                //Schreibe erste Seite
        do {                                            //Führe aus
          draw();                                       //Funktion Kombimodus
        } while (u8g.nextPage());                       //während Seite aktualisiert wird
        statusold = dmxbtstatus[(channel - 1)];         //Setze alten Status gleich dem aktuellen Status für Channel
      }
    }
  }

  if (displ == 0) {                                     //wenn Display aus ist
    if (mode == 1) {                                    //wenn Modus 1 ist
      u8g.firstPage();                                  //Schreibe erste Seite
      do {                                              //Führe aus
        draw2();                                        //Funktion Display-Lock
      } while (u8g.nextPage());                         //während Seite aktualisiert wird
      displ = 2;                                        //Setze displ auf 2 um kontinuierliche Aktualisierung des Displays zu vermeiden
    }
    if (mode == 2) {                                    //wenn Modus 2 ist
      u8g.firstPage();                                  //Schreibe erste Seite
      do {                                              //Führe aus
        draw2();                                        //Funktion Display-Lock
      } while (u8g.nextPage());                         //während Seite aktualisiert wird
      displ = 2;                                        //Setze displ auf 2 um kontinuierliche Aktualisierung des Displays zu vermeiden
    }
  }


  if (digitalRead(30) == LOW) {                                                                                                     //wenn oben gedrückt wird
    presslengthold = millis();                                                                                                      //Speichere Zeitpunkt beim ersten Runterdrücken
    while (digitalRead(30) == LOW) { //up                                                                                           //während oben gedrückt ist
      presslength = millis();                                                                                                       //Aktualisiere Zeit bis Loslassen
    }

    if (presslength != 0) {                                                                                                         //wenn Zeit ungleich 0
      presslengthnew = presslength - presslengthold;                                                                                //Bilde Differenz aus erstes Runterdrücken und Loslassen

      if (presslengthnew > 0 && presslengthnew < 500 && dmxvalues[(channel - 1)] == 0 && dmxbtstatus[(channel - 1)] == 0) {         //wenn Zeit-Differenz größer 0 und kleiner 500, Wert 0 ist und kein Overwrite
        dmxvalues[(channel - 1)] = 0;                                                                                               //Setze DMX-Ausgangswert für Channel auf Wert 0
        dmxbt[(channel - 1)] = dmxvalues[(channel - 1)];                                                                            //Setze Overwrite-Wert für Channel gleich dem DMX-Ausgangswert
        dmxbtstatus[(channel - 1)] = 1;                                                                                             //Setze Overwrite-Status für Channel auf 1
        sendandreset();                                                                                                             //Sende DMX-Pakete und resete Zeiten
      }

      if (presslengthnew > 0 && presslengthnew < 500 && dmxvalues[(channel - 1)] < 255) {                                           //wenn Zeit-Differenz größer 0 und kleiner 500 und DMX-Wert kleiner 255
        dmxvalues[(channel - 1)] = dmxvalues[(channel - 1)] + 1;                                                                    //Erhöhe DMX-Ausgangswert für Channel
        dmxbt[(channel - 1)] = dmxvalues[(channel - 1)];                                                                            //Setze Overwrite-Wert für Channel gleich dem DMX-Ausgangswert
        dmxbtstatus[(channel - 1)] = 1;                                                                                             //Setze Overwrite-Status für Channel auf 1
        sendandreset();                                                                                                             //Sende DMX-Pakete und resete Zeiten
      }

      if (presslengthnew > 0 && presslengthnew < 500 && dmxvalues[(channel - 1)] == 255) {                                          //wenn Zeit-Differenz größer 0 und kleiner 500 und DMX-Wert 255
        dmxvalues[(channel - 1)] = 255;                                                                                             //Setze DMX-Ausgangswert für Channel auf Wert 255
        dmxbt[(channel - 1)] = dmxvalues[(channel - 1)];                                                                            //Setze Overwrite-Wert für Channel gleich dem DMX-Ausgangswert
        dmxbtstatus[(channel - 1)] = 1;                                                                                             //Setze Overwrite-Status für Channel auf 1
        sendandreset();                                                                                                             //Sende DMX-Pakete und resete Zeiten
      }

      if (presslengthnew > 0 && presslengthnew >= 500 && dmxvalues[(channel - 1)] < 255) {                                          //wenn Zeit-Differenz größer 0 und größer gleich 500 und DMX-Wert kleiner 255 ("Highlight")
        dmxvalues[(channel - 1)] = 255;                                                                                             //Setze DMX-Ausgangswert für Channel auf Wert 255
        dmxbt[(channel - 1)] = dmxvalues[(channel - 1)];                                                                            //Setze Overwrite-Wert für Channel gleich dem DMX-Ausgangswert
        dmxbtstatus[(channel - 1)] = 1;                                                                                             //Setze Overwrite-Status für Channel auf 1
        sendandreset();                                                                                                             //Sende DMX-Pakete und resete Zeiten
      }
    }
  }


  if (digitalRead(32) == LOW) {                                                                                                     //wenn unten gedrückt wird
    presslengthold = millis();                                                                                                      //Speichere Zeitpunkt beim ersten Runterdrücken
    while (digitalRead(32) == LOW) {                                                                                                //während unten gedrückt ist
      presslength = millis();                                                                                                       //Aktualisiere Zeit bis Loslassen
    }

    if (presslength != 0) {                                                                                                         //wenn Zeit ungleich 0
      presslengthnew = presslength - presslengthold;                                                                                //Bilde Differenz aus erstes Runterdrücken und Loslassen

      if (presslengthnew > 0 && presslengthnew < 500 && dmxvalues[(channel - 1)] > 0) {                                             //wenn Zeit-Differenz größer 0 und kleiner 500 und Wert größer 0
        dmxvalues[(channel - 1)] = dmxvalues[(channel - 1)] - 1;                                                                    //Reduziere DMX-Ausgangswert für Channel
        dmxbt[(channel - 1)] = dmxvalues[(channel - 1)];                                                                            //Setze Overwrite-Wert für Channel gleich dem DMX-Ausgangswert
        dmxbtstatus[(channel - 1)] = 1;                                                                                             //Setze Overwrite-Status für Channel auf 1
        sendandreset();                                                                                                             //Sende DMX-Pakete und resete Zeiten
      }
      if (presslengthnew > 0 && presslengthnew < 500 && dmxvalues[(channel - 1)] == 0 && dmxbtstatus[(channel - 1)] == 0) {         //wenn Zeit-Differenz größer 0 und kleiner 500, Wert 0 ist und kein Overwrite
        dmxvalues[(channel - 1)] = 0;                                                                                               //Setze DMX-Ausgangswert für Channel auf Wert 0
        dmxbt[(channel - 1)] = dmxvalues[(channel - 1)];                                                                            //Setze Overwrite-Wert für Channel gleich dem DMX-Ausgangswert
        dmxbtstatus[(channel - 1)] = 1;                                                                                             //Setze Overwrite-Status für Channel auf 1
        sendandreset();                                                                                                             //Sende DMX-Pakete und resete Zeiten
      }
      if (presslengthnew > 0 && presslengthnew < 500 && dmxvalues[(channel - 1)] == 0 && dmxbtstatus[(channel - 1)] == 1) {         //wenn Zeit-Differenz größer 0 und kleiner 500, Wert 0 ist und Overwrite aktiv
        dmxvalues[(channel - 1)] = 0;                                                                                               //Setze DMX-Ausgangswert für Channel auf Wert 0
        dmxbt[(channel - 1)] = dmxvalues[(channel - 1)];                                                                            //Setze Overwrite-Wert für Channel gleich dem DMX-Ausgangswert
        dmxbtstatus[(channel - 1)] = 0;                                                                                             //Setze Overwrite-Status für Channel auf 0
        sendandreset();                                                                                                             //Sende DMX-Pakete und resete Zeiten
      }
      if (presslengthnew > 0 && presslengthnew >= 500 && dmxvalues[(channel - 1)] >= 0) {                                           //wenn Zeit-Differenz größer 0 und größer gleich 500 und Wert größer gleich 0
        dmxvalues[(channel - 1)] = 0;                                                                                               //Setze DMX-Ausgangswert für Channel auf Wert 0
        dmxbt[(channel - 1)] = dmxvalues[(channel - 1)];                                                                            //Setze Overwrite-Wert für Channel gleich dem DMX-Ausgangswert
        dmxbtstatus[(channel - 1)] = 0;                                                                                             //Setze Overwrite-Status für Channel auf 0
        sendandreset();                                                                                                             //Sende DMX-Pakete und resete Zeiten
      }
    }
  }

  if (digitalRead(34) == LOW) {                                         //wenn links gedrückt wird
    presslengthold = millis();                                          //Speichere Zeitpunkt beim ersten Runterdrücken
    while (digitalRead(34) == LOW) {                                    //während links gedrückt ist
      presslength = millis();                                           //Aktualisiere Zeit bis Loslassen
    }
    if (presslength != 0) {                                             //wenn Zeit ungleich 0
      presslengthnew = presslength - presslengthold;                    //Bilde Differenz aus erstes Runterdrücken und Loslassen
      if (presslengthnew < 500 && channel > 0) {                        //wenn Zeit-Differenz kleiner 500 und Channel größer 0
        channel = channel - 1;                                          //Reduziere Channel um 1
        if (channel > 0) {                                              //wenn Channel größer 0
          dmxbtsend();                                                  //Sende nur DMX-Paket
        }
        presslength = 0;                                                //resete Zeit
        presslengthnew = 0;                                             //resete Zeit
      }
      if (presslengthnew < 500 && channel == 0) {                       //wenn Zeit-Differenz kleiner 500 und Channel gleich 0
        channel = 512;                                                  //Setze Channel auf 512
        dmxbtsend();                                                    //Sende nur DMX-Paket
        presslength = 0;                                                //resete Zeit
        presslengthnew = 0;                                             //resete Zeit
      }
      if (presslengthnew >= 500 && channel > 100) {                     //wenn Zeit-Differenz größer gleich 500 und Channel größer 100
        channel = channel - 100;                                        //Reduziere Channel um 100
        dmxbtsend();                                                    //Sende nur DMX-Paket
        presslength = 0;                                                //resete Zeit
        presslengthnew = 0;                                             //resete Zeit
      }
      if (presslengthnew >= 500 && channel <= 100) {                    //wenn Zeit-Differenz größer gleich 500 und Wert kleiner gleich 100
        channel = 1;                                                    //Setze Channel auf 1
        dmxbtsend();                                                    //Sende nur DMX-Paket
        presslength = 0;                                                //resete Zeit
        presslengthnew = 0;                                             //resete Zeit
      }
    }
  }

  if (digitalRead(36) == LOW) {                                         //wenn rechts gedrückt wird
    presslengthold = millis();                                          //Speichere Zeitpunkt beim ersten Runterdrücken
    while (digitalRead(36) == LOW) {                                    //während rechts gedrückt ist
      presslength = millis();                                           //Aktualisiere Zeit bis Loslassen

    }
    if (presslength != 0) {                                             //wenn Zeit ungleich 0
      presslengthnew = presslength - presslengthold;                    //Bilde Differenz aus erstes Runterdrücken und Loslassen

      if (presslengthnew < 500 && channel < 513) {                      //wenn Zeit-Differenz kleiner 500 und Channel kleiner 514
        channel = channel + 1;                                          //Erhöhe Channel um 1
        dmxbtsend();                                                    //Sende nur DMX-Paket
        presslength = 0;                                                //resete Zeit
        presslengthnew = 0;                                             //resete Zeit
      }
      if (presslengthnew < 500 && channel == 513) {                     //wenn Zeit-Differenz kleiner 500 und Channel gleich 513
        channel = 1;                                                    //Setze Channel auf 1
        dmxbtsend();                                                    //Sende nur DMX-Paket
        presslength = 0;                                                //resete Zeit
        presslengthnew = 0;                                             //resete Zeit
      }
      if (presslengthnew >= 500 && channel < 411) {                     //wenn Zeit-Differenz größer gleich 500 und Channel kleiner 411
        channel = channel + 100;                                        //Erhöhe Channel um 100
        dmxbtsend();                                                    //Sende nur DMX-Paket
        presslength = 0;                                                //resete Zeit
        presslengthnew = 0;                                             //resete Zeit
      }
      if (presslengthnew >= 500 && channel >= 411) {                    //wenn Zeit-Differenz größer gleich 500 und Channel größer gleich 411
        channel = 512;                                                  //Setze Channel auf 512
        dmxbtsend();                                                    //Sende nur DMX-Paket
        presslength = 0;                                                //resete Zeit
        presslengthnew = 0;                                             //resete Zeit
      }
    }
  }

  if (mode == 0) {                                                                                  //Kabeltest-Modus
    DmxSimple.write(1, 145);                                                                        //Setze Testkanal auf neuen Wert
    DmxSimple.write(256, 216);                                                                      //Setze Testkanal auf neuen Wert
    DmxSimple.write(512, 53);                                                                       //Setze Testkanal auf neuen Wert
    delay(100);                                                                                     //Delay zum sicheren Durchgang
    if (DMXSerial.read(1) == 145 && DMXSerial.read(256) == 216 && DMXSerial.read(512) == 53) {      //wenn eingelesene Werte stimmen
      count1 = count1 + 1;                                                                          //erhöhe count1
    }
    delay(100);                                                                                     //Delay zum sicheren Durchgang
    DmxSimple.write(1, 2);                                                                          //Setze Testkanal auf neuen Wert
    DmxSimple.write(256, 2);                                                                        //Setze Testkanal auf neuen Wert
    DmxSimple.write(512, 2);                                                                        //Setze Testkanal auf neuen Wert
    delay(100);                                                                                     //Delay zum sicheren Durchgang
    if (DMXSerial.read(1) == 2 && DMXSerial.read(256) == 2 && DMXSerial.read(512) == 2) {           //wenn eingelesene Werte stimmen
      count1 = count1 + 1;                                                                          //erhöhe count1
    }

    delay(100);                                                                                     //Delay zum sicheren Durchgang
    DmxSimple.write(1, 100);                                                                        //Setze Testkanal auf neuen Wert
    DmxSimple.write(256, 100);                                                                      //Setze Testkanal auf neuen Wert
    DmxSimple.write(512, 100);                                                                      //Setze Testkanal auf neuen Wert
    delay(100);                                                                                     //Delay zum sicheren Durchgang
    if (DMXSerial.read(1) == 100 && DMXSerial.read(256) == 100 && DMXSerial.read(512) == 100) {     //wenn eingelesene Werte stimmen
      count1 = count1 + 1;                                                                          //erhöhe count1
    }
    delay(100);                                                                                     //Delay zum sicheren Durchgang
    DmxSimple.write(1, 50);                                                                         //Setze Testkanal auf neuen Wert
    DmxSimple.write(256, 50);                                                                       //Setze Testkanal auf neuen Wert
    DmxSimple.write(512, 50);                                                                       //Setze Testkanal auf neuen Wert
    delay(100);                                                                                     //Delay zum sicheren Durchgang
    if (DMXSerial.read(1) == 50 && DMXSerial.read(256) == 50 && DMXSerial.read(512) == 50) {        //wenn eingelesene Werte stimmen
      count1 = count1 + 1;                                                                          //erhöhe count1
    }
    delay(100);                                           //Delay
    if (count1 != 4) {                                    //wenn count1 ungleich erwarteter Zahl
      digitalWrite(10, LOW);                              //LED grün aus
      digitalWrite(11, HIGH);                             //LED rot aus
      ergebnis = 0;                                       //Ergebnis ist negativ (0)
    }
    if (count1 == 4) {                                    //wenn count1 gleich erwarteter Zahl (4)
      digitalWrite(10, HIGH);                             //LED grün an
      digitalWrite(11, LOW);                              //LED rot aus
      ergebnis = 1;                                       //Ergebnis ist positiv (1)
    }
    count1 = 0;                                           //Reset Zähler
    DmxSimple.write(1, 0);                                //Reset Testkanal
    DmxSimple.write(256, 0);                              //Reset Testkanal
    DmxSimple.write(512, 0);                              //Reset Testkanal
    BTSerial.print("T");                                  //Sende Paket-Indikator T
    BTSerial.print(ergebnis);                             //Sende Ergebnis
    BTSerial.print("X");                                  //Sende Paket-Abschluss
    delay(50);                                            //Delay vor neuem Durchgang
  }

  if (mode == 1) {                                        //DMX-Kombimodus
    digitalWrite(10, LOW);                                //LED aus
    digitalWrite(11, LOW);                                //LED aus
    for (int i = 0; i <= 511; i++) {                      //for-Schleife zum Durchgehen aller Kanäle, folgende Aktionen jeweils pro Kanal
      if (dmxvaluesin[i] != DMXSerial.read((i + 1))) {    //wenn gelesener Wert ungleich dem bisherigen Eintrag
        dmxvaluesin[i] = DMXSerial.read((i + 1));         //Eintrag ist gleich dem neuen Wert
        dmxvalues[i] = dmxvaluesin[i];                    //DMX-Ausgang ist gleich dem Eingang
        if (dmxbtstatus[i] == 0) {                        //wenn kein Overwrite-Status da ist
          BTSerial.print("C");                            //Sende Paket-Indikator C
          BTSerial.print((i + 1));                        //Sende Kanal
          BTSerial.print("/");                            //Sende Paket-Trenner
          BTSerial.print(dmxvalues[i]);                   //Sende Wert
          BTSerial.print("X");                            //Sende Paket-Abschluss
        }
      }
      if (dmxbtstatus[i] == 1) {                          //wenn Status gleich eins gesetzt wird
        dmxvalues[i] = dmxbt[i];                          //DMX-Ausgang gleich Überschreiben-Wert
      }
      DmxSimple.write((i + 1), dmxvalues[i]);             //DMX-Ausgabe mit Versatz um 1, da Kanäle von 1-512
    }
  }

  if (mode == 2) {                                        //ArtNet-Kombimodus

    digitalWrite(10, LOW);                                //LED aus
    digitalWrite(11, LOW);                                //LED aus
    if (artnet.read() == ART_DMX) {                       //wenn ArtNet-Pakete ankommen
      for (int i = 0; i <= 511; i++) {                    //for-Schleife zum Durchgehen aller Kanäle, folgende Aktionen jeweils pro Kanal
        if (dmxvaluesin[i] != artnet.getDmxFrame()[i]) {  //wenn gelesener Wert ungleich dem bisherigen Eintrag
          dmxvaluesin[i] = (artnet.getDmxFrame()[i]);     //Eintrag ist gleich dem neuen Wert
          dmxvalues[i] = dmxvaluesin[i];                  //DMX-Ausgang ist gleich dem Eingang
          if (dmxbtstatus[i] == 0) {                      //wenn kein Overwrite-Status da ist
            BTSerial.print("C");                          //Sende Paket-Indikator C
            BTSerial.print((i + 1));                      //Sende Kanal
            BTSerial.print("/");                          //Sende Paket-Trenner
            BTSerial.print(dmxvalues[i]);                 //Sende Wert
            BTSerial.print("X");                          //Sende Paket-Abschluss
          }
        }
        if (dmxbtstatus[i] == 1) {                        //wenn Status gleich eins gesetzt wird
          dmxvalues[i] = dmxbt[i];                        //DMX-Ausgang gleich Überschreiben-Wert
        }
        DmxSimple.write((i + 1), dmxvalues[i]);           //DMX-Ausgabe mit Versatz um 1, da Kanäle von 1-512
      }
    }
  }
}
